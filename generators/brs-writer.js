var GenName = "BrsWriter";

var BrsOwnerIndex = function(arr, own) {
	for(var i = 0; i < arr.length; i++) {
		if(arr[i].name == own.name && arr[i].id == own.id) return i;
	}
	return -1;
}
var BrsColorIndex = function(arr, own) {
	for(var i = 0; i < arr.length; i++) {
		if(arr[i][0] == own[0] && arr[i][1] == own[1] && arr[i][2] == own[2] && arr[i][3] == own[3]) return i;
	}
	return -1;
}

Generators[GenName] = new StagedBrickGenerator(GenName, [new SBG_SlowIterator(function(inst) {
	var tb = inst.bricks[inst.currI];
	
	var nb = {};
	var assetname;
	var mtlname;
	var owner;
	if(tb.BrsRef != "") {
		assetname = tb.BrsRef;
		mtlname = tb.BrsData.Material;
		owner = tb.BrsData.Owner;
	} else {
		switch(tb.IntRef) {
			case "Ramp":
				assetname = "PB_DefaultRamp";
				break;
			case "RampCorner":
				assetname = "PB_DefaultRampCorner";
				break;
			default:
				assetname = "PB_DefaultBrick";
		}
		owner = {
			name: 'Unknown',
			id: '00000000-0000-0000-0000-000000000000'
		}
		mtlname = inst.defaultMtl;
	}
	var color = [tb.Color.r*255,tb.Color.g*255,tb.Color.b*255,255];
	
	var assetind = inst.brsdata.brick_assets.indexOf(assetname);
	if(assetind == -1) {
		nb.asset_name_index = inst.brsdata.brick_assets.length;
		inst.brsdata.brick_assets.push(assetname);
	} else nb.asset_name_index = assetind;
	var mtlind = inst.brsdata.materials.indexOf(mtlname);
	if(mtlind == -1) {
		nb.material = inst.brsdata.materials.length;
		inst.brsdata.materials.push(mtlname);
	} else nb.material = mtlind;
	var ownind = BrsOwnerIndex(inst.brsdata.brick_owners, owner);
	if(ownind == -1) {
		nb.owner_index = inst.brsdata.brick_owners.length;
		inst.brsdata.brick_owners.push(owner);
	} else nb.owner_index = ownind;
	var colorind = BrsColorIndex(inst.brsdata.colors, color);
	if(colorind == -1) {
		inst.brsdata.colors.push(color);
		nb.color = inst.brsdata.colors.length-1;
	}
	else nb.color = colorind;
	
	if(typeof tb.BrsData.IsProcedural === "undefined" || tb.BrsData.IsProcedural) //TODO: make generators set this
		nb.size = [Math.floor(tb.BoundingBox.y*5), Math.floor(tb.BoundingBox.x*5), Math.floor(tb.BoundingBox.z*2)];
	else
		nb.size = [0, 0, 0];
	
	//nb.color = [tb.Color.r*255,tb.Color.g*255,tb.Color.b*255,255];
	
	nb.position = [tb.Position.y*10, tb.Position.x*10, tb.Position.z*4];
	nb.direction = tb.FacingIndex;
	nb.rotation = tb.RotationIndex;
	nb.collision = tb.Collision;
	nb.visibility = tb.Rendering;
	
	inst.brsdata.bricks.push(nb);
	
	inst.currI++;
	return inst.currI == inst.maxI;
}, {
	RunSpeed: 50,
	MaxExecTime: 40,
	OnStagePause: function(inst) {
		return "Preparing BRS... " + inst.currI + "/" + inst.maxI;
	}
})], {
	Controls: {},
	OnSetup: function(inst) {
		inst.bricks = inst.callerParams.BrickList;
		
		if(inst.bricks.length == 0) {
			inst.abort = "No bricks to save";
			return;
		}
		
		inst.defaultMtl = 'BMC_Plastic';
		
		inst.brsdata = {
			description: "Generated by BRSerker",
			version: 4,
			brick_assets: [],
			brick_owners: [],
			materials: [],
			bricks: [],
			colors: []
		}
		
		
		inst.currI = 0;
		inst.maxI = inst.bricks.length;
	},
	OnFinalize: function(inst) {
		var nbd = BRS.write(inst.brsdata);
		BlobDownload("generated.brs", [nbd], "octet/stream");
	},
	Description: "Saves bricks to a Brickadia save file (.BRS). Will retain information from BrsReader!<br><b><span class='warntri'></span>WARNING: DO NOT LOAD GENERATED FILES WITH OWNERSHIP</b> (it's bugged and will crash your game)"
});
var o = new Option(GenName, GenName);
$(o).html(GenName);
$("#generator-type").append(o);
Generators[GenName].OptionElement = o;